package csvtool.operation;

import csvtool.data.Context;
import csvtool.data.FileCache;
import csvtool.enums.Operations;
import csvtool.enums.Settings;
import csvtool.header.HeaderParser;
import csvtool.utils.LogWrapper;

import java.util.List;

public class OperationHeaderAdd extends Operation implements AutoCloseable
{
    private final LogWrapper LOGGER = new LogWrapper(this.getClass());
    private final HeaderParser PARSER;
    private FileCache FILE;
    private FileCache OUT;

    public OperationHeaderAdd(Operations op)
    {
        super(op);
        this.PARSER = new HeaderParser();
        this.FILE = new FileCache();
        this.OUT = new FileCache();
    }

    @Override
    public boolean runOperation(Context ctx)
    {
        if (ctx.getOpt().isQuiet())
        {
            super.toggleQuiet(true);
            LOGGER.toggleQuiet(true);
        }

        if (ctx.getOpt().isDebug())
        {
            super.toggleDebug(true);
            LOGGER.toggleDebug(true);
        }

        if (ctx.getOpt().isAnsiColors())
        {
            super.toggleAnsiColor(true);
            LOGGER.toggleAnsiColor(true);
        }

        if (!ctx.getOpt().hasHeaders())
        {
            LOGGER.error("runOperation(): AddHeaders FAILED, a Headers Config file is required.");
            return false;
        }

        if (!ctx.getOpt().hasOutput())
        {
            LOGGER.error("runOperation(): AddHeaders FAILED, a Output file is required.");
            return false;
        }

        LOGGER.debug("runOperation(): --> Input [{}], Headers Config [{}], Output [{}]", ctx.getInputFile(), ctx.getSettingValue(Settings.HEADERS), ctx.getOpt().hasOutput() ? ctx.getSettingValue(Settings.OUTPUT) : "<not_used>");

        if (this.readFiles(ctx.getInputFile(), false, ctx.getOpt().isDebug()))
        {
            LOGGER.debug("runOperation(): --> Input [{}] read successfully.", ctx.getInputFile());

            if (this.PARSER.init(ctx, false))
            {
                LOGGER.debug("runOperation(): --> Config Parser initialized.");

                if (this.PARSER.loadConfig())
                {
                    if (this.PARSER.getOutputHeader() != null)
                    {
                        this.OUT.setFileName(ctx.getSettingValue(Settings.OUTPUT));
                        this.OUT.setHeader(this.PARSER.getOutputHeader());

                        if (this.copyDataNoHeaders())
                        {
                            if (this.writeFile(this.OUT, ctx.getOpt().isApplyQuotes(), false, ctx.getOpt().isDebug(), null))
                            {
                                LOGGER.info("runOperation(): --> File Output saved as [{}].", ctx.getSettingValue(Settings.OUTPUT));
                                return true;
                            }
                            else
                            {
                                LOGGER.error("runOperation(): --> File output [{}] has failed!", ctx.getSettingValue(Settings.OUTPUT));
                                return false;
                            }
                        }
                        else
                        {
                            LOGGER.error("runOperation(): --> File copyData() -> output [{}] has failed!", ctx.getSettingValue(Settings.OUTPUT));
                            return false;
                        }
                    }
                    else
                    {
                        LOGGER.error("runOperation(): --> Failed to load output headers from config [{}]!", this.PARSER.getHeaderConfigFile());
                        return false;
                    }
                }
                else
                {
                    LOGGER.error("runOperation(): --> Failed to load headers config [{}]!", this.PARSER.getHeaderConfigFile());
                    return false;
                }
            }
        }

        LOGGER.error("runOperation(): General Operation failure.");
        return false;
    }

    @Override
    public void displayHelp()
    {
        System.out.print("HeaderAdd Operation:\n");
        System.out.printf("\tAliases: %s\n\n", Operations.HEADER_ADD.getAlias().toString());

        System.out.print("This function accepts one input, and one output file;\n");
        System.out.print("Which utilizes the 'headers.json' as a configuration file that is generated by HeaderSave operation.\n");
        System.out.print("Please see the '--header-save' operation to see how it may be used;\n");
        System.out.print("\n");
    }

    private boolean readFiles(String input, boolean ignoreQuotes, boolean debug)
    {
        LOGGER.debug("readFiles(): Reading files ...");

        this.FILE = this.readFileNoHeaders(input, ignoreQuotes, debug);

        if (this.FILE == null)
        {
            LOGGER.error("readFiles(): Input File Cache is Empty!");
            return false;
        }

        return true;
    }

    private boolean copyDataNoHeaders()
    {
        for (int i = 0; i < this.FILE.getFile().size(); i++)
        {
            List<String> entry = this.FILE.getFile().get(i);

            if (!entry.isEmpty())
            {
                this.OUT.addLine(entry);
            }
        }

        return true;
    }

    @Override
    public void clear()
    {
        if (this.FILE != null && !this.FILE.isEmpty())
        {
            this.FILE.clear();
        }
        if (this.OUT != null && !this.OUT.isEmpty())
        {
            this.OUT.clear();
        }
        if (this.PARSER != null && !this.PARSER.isEmpty())
        {
            this.PARSER.clear();
        }
    }

    @Override
    public void close() throws Exception
    {
        if (this.FILE != null)
        {
            this.FILE.close();
        }
        if (this.OUT != null)
        {
            this.OUT.close();
        }
        if (this.PARSER != null)
        {
            this.PARSER.close();
        }
    }
}
